---
type: docs
order: 5
title: "Custom Stores"
permalink: docs/stores/
category: "Docs"
---

> This section concerns storing the internal application state, if you work with React/Redux, for example. If none of this rings a bell, you can safely skip this section.

By default, bulky stores its internal state in an object.

If your app uses a state management library such as [Redux](https://redux.js.org), it can be useful to have bulky store its state there instead—that way, you could write custom uploader UI components in the same way as the other components in the application.

bulky comes with two state management solutions (stores):

- `@bulky/store-default`, a basic object-based store.
- `@bulky/store-redux`, a store that uses a key in a Redux store.

You can also use a third-party store:

- [bulky-store-ngrx](https://github.com/rimlin/bulky-store-ngrx/), keeping bulky state in a key in an [Ngrx](https://github.com/ngrx/platform) store for use with Angular.

## Using stores

To use a store, pass an instance to the [`store` option](/docs/bulky#store-defaultstore) in the bulky constructor:

```js
import DefaultStore from "@bulky/store-default";

const bulky = new bulky({
  store: new DefaultStore(),
});
```

### `DefaultStore`

bulky uses the `DefaultStore`…by default! You do not need to do anything to use it.
It does not take any options.

### `ReduxStore`

The `ReduxStore` stores bulky state on a key in an existing Redux store.
The `ReduxStore` dispatches `bulky/STATE_UPDATE` actions to update state.
When the state in Redux changes, it notifies bulky.
This way, you get most of the benefits of Redux, including support for the Redux Devtools and time traveling!

Here is how you can integrate bulky’s `ReduxStore`:

```js
import bulky from "@bulky/core";
import * as ReduxStore from "@bulky/store-redux";
import * as Redux from "redux";

function createStore(reducers = {}) {
  const reducer = Redux.combineReducers({
    ...reducers,
    bulky: ReduxStore.reducer,
  });
  return Redux.createStore(reducer);
}

const store = new ReduxStore.ReduxStore({ store: createStore() });
const bulky = new bulky({ store });
```

#### `opts.store`

Pass a Redux store instance, from `Redux.createStore`.
This instance should have the bulky reducer mounted somewhere already.

#### `opts.id`

By default, the `ReduxStore` assumes bulky state is stored on a `state.bulky[id]` key.
`id` is randomly generated by the store constructor, but can be specified by passing an `id` option if it should be predictable.

```js
ReduxStore({
  store,
  id: "avatarUpload",
});
```

#### `opts.selector`

If you’d rather not store the bulky state under the `state.bulky` key at all, use the `selector` option to the `ReduxStore` constructor to tell it where to find state instead:

```js
const bulky = new bulky({
  store: ReduxStore({
    store,
    id: "avatarUpload",
    selector: (state) => state.pages.profile.bulky.avatarUpload,
  }),
});
```

Note that when specifying a custom selector, you **must** also specify a custom store ID. The store `id` tells the reducer in which property it should put bulky’s state. The selector must then take the state from that property. In the example, we set the ID to `avatarUpload` and take the state from the `[reducer mount path].avatarUpload`.

If your app uses [`reselect`](https://npmjs.com/package/reselect), its selectors work well with this!

## Implementing Stores

An bulky store is an object with three methods.

- `getState()` - Return the current state object.
- `setState(patch)` - Merge the object `patch` into the current state.
- `subscribe(listener)` - Call `listener` whenever the state changes.
  `listener` is a function that should receive three parameters:
  `(prevState, nextState, patch)`

  The `subscribe()` method should return a function that “unsubscribes” (removes) the `listener`.

The default store implementation, for example, looks a bit like this:

```js
function createDefaultStore() {
  let state = {};
  const listeners = new Set();

  return {
    getState: () => state,
    setState: (patch) => {
      const prevState = state;
      const nextState = { ...prevState, ...patch };

      state = nextState;

      listeners.forEach((listener) => {
        listener(prevState, nextState, patch);
      });
    },
    subscribe: (listener) => {
      listeners.add(listener);
      return () => listeners.remove(listener);
    },
  };
}
```

A pattern like this, where users can pass options via a function call if necessary, is recommended.

See the [@bulky/store-default](https://github.com/transloadit/bulky/tree/main/packages/%40bulky/store-default) package for more inspiration.
